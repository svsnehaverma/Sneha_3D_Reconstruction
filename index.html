import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Loader2, ImagePlus, UploadCloud, PlayCircle, Camera, Info, Download, RotateCcw, University } from "lucide-react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

// --- Small utility to read files as data URLs ---
function readAsDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Export a simple PLY string from point cloud [{x,y,z,r,g,b}]
function exportPLY(points) {
  let header = `ply\nformat ascii 1.0\n` +
    `element vertex ${points.length}\n` +
    `property float x\nproperty float y\nproperty float z\nproperty uchar red\nproperty uchar green\nproperty uchar blue\nend_header\n`;
  const body = points.map(p => `${p.x} ${p.y} ${p.z} ${p.r} ${p.g} ${p.b}`).join("\n");
  return header + body + "\n";
}

// Build a quick pseudo-3D from the first image: a height map based on brightness (for instant demo)
async function quickReliefPointCloudFromImage(imgDataUrl, sampleStep = 8, zScale = 0.5) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const w = img.width, h = img.height;
      // constrain size for performance
      const maxSide = 640;
      let scale = 1;
      if (Math.max(w, h) > maxSide) {
        scale = maxSide / Math.max(w, h);
      }
      const W = Math.round(w * scale);
      const H = Math.round(h * scale);
      canvas.width = W; canvas.height = H;
      ctx.drawImage(img, 0, 0, W, H);
      const { data } = ctx.getImageData(0, 0, W, H);
      const points = [];
      for (let y = 0; y < H; y += sampleStep) {
        for (let x = 0; x < W; x += sampleStep) {
          const i = (y * W + x) * 4;
          const r = data[i], g = data[i+1], b = data[i+2];
          const brightness = (0.299*r + 0.587*g + 0.114*b) / 255; // 0..1
          // Center the point cloud around origin
          const X = x - W/2;
          const Y = H/2 - y;
          const Z = (brightness - 0.5) * (W+H)/2 * zScale;
          points.push({ x: X, y: Y, z: Z, r, g, b });
        }
      }
      resolve(points);
    };
    img.src = imgDataUrl;
  });
}

// Three.js viewer component
function PointCloudViewer({ points, texturedPlaneDataUrl }) {
  const mountRef = useRef(null);
  const rendererRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const controlsRef = useRef(null);
  const meshRef = useRef(null);

  useEffect(() => {
    const mount = mountRef.current;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    mount.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(45, mount.clientWidth / mount.clientHeight, 1, 10000);
    camera.position.set(0, 0, 800);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(1, 1, 1);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    // Grid + axes helpers
    const grid = new THREE.GridHelper(1000, 20, 0x444444, 0x222222);
    grid.position.y = -300;
    scene.add(grid);
    const axes = new THREE.AxesHelper(150);
    scene.add(axes);

    // Add textured plane of original image (for visual comparison)
    if (texturedPlaneDataUrl) {
      const tex = new THREE.TextureLoader().load(texturedPlaneDataUrl);
      tex.colorSpace = THREE.SRGBColorSpace;
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(400, 300),
        new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide })
      );
      plane.position.set(-260, 120, -50);
      plane.rotation.y = Math.PI * -0.12;
      scene.add(plane);
    }

    // Create point cloud geometry
    const geometry = new THREE.BufferGeometry();
    if (points && points.length) {
      const positions = new Float32Array(points.length * 3);
      const colors = new Float32Array(points.length * 3);
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        positions[i*3] = p.x;
        positions[i*3+1] = p.y;
        positions[i*3+2] = p.z;
        colors[i*3] = p.r / 255;
        colors[i*3+1] = p.g / 255;
        colors[i*3+2] = p.b / 255;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    }

    const material = new THREE.PointsMaterial({ size: 3, vertexColors: true });
    const pointsMesh = new THREE.Points(geometry, material);
    scene.add(pointsMesh);
    meshRef.current = pointsMesh;

    const onResize = () => {
      if (!mount) return;
      const { clientWidth, clientHeight } = mount;
      renderer.setSize(clientWidth, clientHeight);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", onResize);

    const animate = () => {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    };
    animate();

    rendererRef.current = renderer;
    sceneRef.current = scene;
    cameraRef.current = camera;
    controlsRef.current = controls;

    return () => {
      window.removeEventListener("resize", onResize);
      if (renderer) {
        renderer.dispose();
        mount.removeChild(renderer.domElement);
      }
      scene.clear();
    };
  }, []);

  useEffect(() => {
    // Replace geometry when points change
    if (!meshRef.current) return;
    const geometry = new THREE.BufferGeometry();
    if (points && points.length) {
      const positions = new Float32Array(points.length * 3);
      const colors = new Float32Array(points.length * 3);
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        positions[i*3] = p.x;
        positions[i*3+1] = p.y;
        positions[i*3+2] = p.z;
        colors[i*3] = p.r / 255;
        colors[i*3+1] = p.g / 255;
        colors[i*3+2] = p.b / 255;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    }
    meshRef.current.geometry.dispose();
    meshRef.current.geometry = geometry;
  }, [points]);

  return <div ref={mountRef} className="w-full h-[520px] rounded-2xl border border-white/10"/>;
}

export default function App() {
  const [files, setFiles] = useState([]); // File[]
  const [imageUrls, setImageUrls] = useState([]); // string[]
  const [busy, setBusy] = useState(false);
  const [progress, setProgress] = useState(0);
  const [points, setPoints] = useState([]); // point cloud for demo
  const [downloadHref, setDownloadHref] = useState("");

  const handleFiles = useCallback(async (list) => {
    const arr = Array.from(list || []);
    const images = arr.filter(f => f.type.startsWith("image/"));
    setFiles(images);
    const urls = await Promise.all(images.map(readAsDataURL));
    setImageUrls(urls);
    setPoints([]);
    setDownloadHref("");
  }, []);

  const onDrop = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length) {
      handleFiles(e.dataTransfer.files);
    }
  }, [handleFiles]);

  const onBrowse = useCallback((e) => {
    if (e.target.files && e.target.files.length) {
      handleFiles(e.target.files);
    }
  }, [handleFiles]);

  useEffect(() => {
    const onDragOver = (e) => { e.preventDefault(); };
    window.addEventListener("dragover", onDragOver);
    return () => window.removeEventListener("dragover", onDragOver);
  }, []);

  const generateQuick3D = useCallback(async () => {
    if (!imageUrls.length) return;
    setBusy(true);
    setProgress(5);
    // Step 1: build quick relief from first image
    const pts = await quickReliefPointCloudFromImage(imageUrls[0], 6, 0.7);
    setProgress(70);
    // Step 2: (placeholder) optional denoise / normalization
    const normalized = pts.map(p => ({ ...p, z: p.z }));
    setPoints(normalized);
    setProgress(90);
    // Step 3: create PLY for download
    const ply = exportPLY(normalized);
    const blob = new Blob([ply], { type: 'text/plain' });
    const href = URL.createObjectURL(blob);
    setDownloadHref(href);
    setProgress(100);
    setBusy(false);
  }, [imageUrls]);

  const resetAll = () => {
    setFiles([]);
    setImageUrls([]);
    setPoints([]);
    setDownloadHref("");
    setProgress(0);
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-900 via-slate-950 to-black text-slate-100">
      <header className="sticky top-0 z-20 backdrop-blur bg-slate-900/60 border-b border-white/10">
        <div className="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-xl bg-indigo-600/90 flex items-center justify-center shadow-lg shadow-indigo-600/40">
              <University className="w-6 h-6" />
            </div>
            <div>
              <h1 className="text-xl font-semibold">Structure‑from‑Motion (SfM) – Web Lab</h1>
              <p className="text-xs text-slate-400">Developed by Newcastle University • Client‑side demo</p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Badge variant="outline" className="bg-white/5">Beta</Badge>
          </div>
        </div>
      </header>

      <main className="max-w-6xl mx-auto px-4 py-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-1 space-y-4">
          <Card className="bg-white/5 border-white/10">
            <CardContent className="p-4 space-y-4">
              <h2 className="text-lg font-semibold flex items-center gap-2"><Camera className="w-5 h-5"/> Images</h2>
              <div
                onDrop={onDrop}
                className="rounded-2xl border border-dashed border-white/20 bg-white/5 p-4 text-center flex flex-col items-center gap-3 hover:border-indigo-400/60 transition"
              >
                <UploadCloud className="w-8 h-8 text-slate-300"/>
                <p className="text-sm text-slate-300">Drag & drop your photos here</p>
                <p className="text-xs text-slate-500">or</p>
                <div>
                  <label className="inline-flex items-center gap-2 cursor-pointer">
                    <Input type="file" accept="image/*" multiple onChange={onBrowse} className="hidden" />
                    <span className="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 transition text-sm flex items-center gap-2"><ImagePlus className="w-4 h-4"/> Browse</span>
                  </label>
                </div>
                <p className="text-[11px] text-slate-500">Use 5–20 photos of the same object/scene for best results (true SfM requires feature matching across views).</p>
              </div>

              {imageUrls.length > 0 && (
                <div>
                  <div className="flex items-center justify-between mb-2">
                    <h3 className="text-sm font-medium">Selected ({imageUrls.length})</h3>
                    <Button variant="ghost" size="sm" onClick={resetAll} className="text-slate-300 hover:text-white"><RotateCcw className="w-4 h-4 mr-1"/>Reset</Button>
                  </div>
                  <div className="grid grid-cols-4 gap-2 max-h-48 overflow-auto pr-1">
                    {imageUrls.map((src, idx) => (
                      <img key={idx} src={src} alt={`img-${idx}`} className="w-full h-20 object-cover rounded-lg border border-white/10"/>
                    ))}
                  </div>
                </div>
              )}

              <div className="pt-2 flex items-center gap-2">
                <Button onClick={generateQuick3D} disabled={!imageUrls.length || busy} className="gap-2">
                  {busy ? <Loader2 className="w-4 h-4 animate-spin"/> : <PlayCircle className="w-4 h-4"/>}
                  Generate 3D (Quick Preview)
                </Button>
                {downloadHref && (
                  <a href={downloadHref} download="preview_pointcloud.ply" className="px-3 py-2 rounded-xl bg-white/10 hover:bg-white/20 text-sm flex items-center gap-2 border border-white/10">
                    <Download className="w-4 h-4"/> PLY
                  </a>
                )}
              </div>

              {busy && (
                <div className="pt-2">
                  <Progress value={progress} className="h-2" />
                  <p className="text-xs text-slate-400 mt-2">Processing images… (client-side demo)</p>
                </div>
              )}
            </CardContent>
          </Card>

          <Alert className="bg-indigo-950/60 border-indigo-500/30">
            <AlertTitle className="flex items-center gap-2"><Info className="w-4 h-4"/> What this demo does</AlertTitle>
            <AlertDescription className="text-sm text-slate-300">
              This is a <span className="font-semibold">browser‑only</span> prototype. The <em>Generate 3D (Quick Preview)</em> creates a colored point cloud by turning the first image into a height‑map based on brightness. 
              It is <span className="font-semibold">not full SfM</span>.
              For true Structure‑from‑Motion (feature detection, matching, camera pose estimation, triangulation, bundle adjustment, meshing), connect a backend (e.g. COLMAP/OpenMVG via WebAssembly or server) using the API spec below.
            </AlertDescription>
          </Alert>

          <Card className="bg-white/5 border-white/10">
            <CardContent className="p-4 space-y-2">
              <h3 className="text-sm font-semibold">Backend API Contract (for real SfM)</h3>
              <pre className="text-xs whitespace-pre-wrap bg-black/40 p-3 rounded-xl border border-white/10">
POST /api/sfm/jobs
Content-Type: multipart/form-data
files: images[]
--&gt; returns {{ jobId }}

GET /api/sfm/jobs/:id
--&gt; {{ status: 'queued|running|done|error', result: {{ plyUrl, objUrl, mtlUrl, textureUrl }} }}

/* Swap generateQuick3D() to call POST, then poll GET until done, and load the PLY/OBJ into the viewer. */
              </pre>
            </CardContent>
          </Card>
        </div>

        <div className="lg:col-span-2 space-y-4">
          <Card className="bg-white/5 border-white/10">
            <CardContent className="p-0">
              <div className="p-4 border-b border-white/10 flex items-center justify-between">
                <div>
                  <h2 className="text-lg font-semibold">3D Viewer</h2>
                  <p className="text-xs text-slate-400">Pan: drag • Zoom: wheel • Rotate: right‑drag</p>
                </div>
                {points?.length ? (
                  <Badge className="bg-green-700/60 border border-green-500/50">Point Cloud: {points.length.toLocaleString()} pts</Badge>
                ) : (
                  <Badge variant="outline" className="bg-white/5">No point cloud</Badge>
                )}
              </div>
              <div className="p-3">
                <PointCloudViewer points={points} texturedPlaneDataUrl={imageUrls[0]} />
              </div>
            </CardContent>
          </Card>

          <Tabs defaultValue="about" className="w-full">
            <TabsList>
              <TabsTrigger value="about">About</TabsTrigger>
              <TabsTrigger value="how">How it Works</TabsTrigger>
              <TabsTrigger value="credits">Credits</TabsTrigger>
            </TabsList>
            <TabsContent value="about" className="space-y-2">
              <Card className="bg-white/5 border-white/10">
                <CardContent className="p-4 text-sm leading-relaxed text-slate-200">
                  <p>
                    <strong>Structure‑from‑Motion (SfM)</strong> recovers 3D structure and camera motion from overlapping 2D images. This web app provides a modern interface for uploading photos, monitoring processing, and viewing results entirely in the browser.
                  </p>
                  <p className="mt-2">
                    <strong>Developed by Newcastle University</strong> for research and teaching demos. The quick preview here is a height‑map transformation for instant feedback; swap in a server or WebAssembly build of COLMAP/OpenMVG for full reconstructions.
                  </p>
                </CardContent>
              </Card>
            </TabsContent>
            <TabsContent value="how" className="space-y-2">
              <Card className="bg-white/5 border-white/10">
                <CardContent className="p-4 text-sm text-slate-200">
                  <ol className="list-decimal ml-5 space-y-1">
                    <li>Upload 5–20 photos with good overlap and varying viewpoints.</li>
                    <li>Client shows a <em>Quick Preview</em> (height‑map point cloud) from the first image.</li>
                    <li>In production, the client would send images to an SfM engine (features → matches → poses → triangulation → bundle adjustment → meshing).</li>
                    <li>Results (PLY/OBJ + textures) are streamed back and displayed in the viewer.</li>
                  </ol>
                </CardContent>
              </Card>
            </TabsContent>
            <TabsContent value="credits" className="space-y-2">
              <Card className="bg-white/5 border-white/10">
                <CardContent className="p-4 text-sm text-slate-200">
                  <p>UI: React + Tailwind + shadcn/ui • 3D: three.js • Controls: OrbitControls</p>
                  <p className="mt-1">Copyright © {new Date().getFullYear()} Newcastle University. All rights reserved.</p>
                </CardContent>
              </Card>
            </TabsContent>
          </Tabs>
        </div>
      </main>

      <footer className="max-w-6xl mx-auto px-4 pb-8 text-xs text-slate-500">
        <p>
          Disclaimer: This page runs solely in your browser. True SfM requires a dedicated engine (COLMAP/OpenMVG/OpenSfM). Hook up the provided API contract to enable end‑to‑end reconstructions and texture meshes.
        </p>
      </footer>
    </div>
  );
}
